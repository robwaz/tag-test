Semantic gaps can occur (and lead to security issues) at the interface of any two technologies.
So far, we have seen them happen between:

- A web application and the file system, leading to path traversal.
- A web application and the command line shell, leading to command injection.
- A web application and the database, leading to SQL injection.

One part of the web application story that we have not yet looked at is the _web browser_.
We will remedy that oversight with this challenge.

A modern web browser is an extraordinarily complex piece of software.
It renders [HTML](https://en.wikipedia.org/wiki/HTML), executes [JavaScript](https://en.wikipedia.org/wiki/JavaScript), parses [CSS](https://en.wikipedia.org/wiki/CSS), lets you access pwn.college, and much much more.
Specifically important to our purposes is the HTML that you have seen being generated by every challenge in this module.
When the web application generated paths, we ended up with path traversals.
When the web application generated shell commands, we ended up with shell injections.
When the web application generated SQL queries, we ended up with SQL injections.
Do we really think HTML will fare any better?
Of course not.

The class of vulnerabilities in which injections occur into client-side web data (such as HTML) is called _Cross Site Scripting_, or XSS for short (to avoid the name collision with Cascading Style Sheets).
Unlike the previous injections, where the victim was the web server itself, the victims of XSS are _other users of the web application_.
In a typical XSS exploit, an attacker will cause their own code to be injected into (typically) the HTML produced by a web application and viewed by a victim user.
This will then allow the attacker to gain some control within the victim's browser, leading to a number of potential downstream shenanigans.

This challenge is a very first step in this direction.
As before, you will have the `/challenge/server` web server.
This challenge explores something called _Stored XSS_, which means that data that you store on the server (in this case, posts in a forum) will end up being shown to a victim user.
Thus, we need a victim to view these posts!
You will now have a `/challenge/victim` program that simulates a victim user visiting the web server.

Set up your attack and invoke `/challenge/victim` with the URL that will trigger the Stored XSS.
In this level, all you have to do is inject a textbox.
If our victim script sees three textboxes, we will give you the flag!

----
**DEBUGGING:**
How do you debug these sorts of attacks?
The most common thing to go wrong in this simple scenario is that the resulting post-injection HTML is invalid.
Here, the View Source functionality of your browser can help.
You can either try launching your attack against the web browser in the DOJO's GUI Desktop (e.g., set up the XSS, then visit with the DOJO's Firefox rather than with `/challenge/victim`), and View Source, or just use curl and read the result.
The result, after you inject your payload, should still be valid (but newly-evil) HTML!
