#define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

uint64_t sp_;
uint64_t bp_;
uint64_t sz_;
uint64_t cp_;
uint64_t cv_;
uint64_t si_;
uint64_t rp_;

#define GET_SP(sp) asm volatile ("mov %0, rsp" : "=r"(sp) : : );
#define GET_BP(bp) asm volatile ("mov %0, rbp" : "=r"(bp) : : );
#define GET_CANARY(cn) asm volatile ("mov %0, QWORD PTR [fs:0x28]" : "=r"(cn) : : );
#define GET_FRAME_WORDS(sz_, sp, bp, rp_) GET_SP(sp); GET_BP(bp); sz_ = (bp-sp)/8+2; rp_ = bp+8;
#define FIND_CANARY(cnp, cv, start)                                     \
  {                                                                     \
    cnp = start;                                                        \
    GET_CANARY(cv);                                                     \
    while (*(uint64_t *)cnp != cv) cnp = (uint64_t)cnp - 8;   \
  }

void DUMP_STACK(uint64_t sp, uint64_t n)
{
    printf("+---------------------------------+-------------------------+--------------------+\n");
    printf("| %31s | %23s | %18s |\n", "Stack location", "Data (bytes)", "Data (LE int)");
    printf("+---------------------------------+-------------------------+--------------------+\n");
    for (si_ = 0; si_ < n; si_++)
    {
        printf("| 0x%016lx (rsp+0x%04x) | %02x %02x %02x %02x %02x %02x %02x %02x | 0x%016lx |\n",
               sp+8*si_, 8*si_,
               *(uint8_t *)(sp+8*si_+0), *(uint8_t *)(sp+8*si_+1), *(uint8_t *)(sp+8*si_+2), *(uint8_t *)(sp+8*si_+3),
               *(uint8_t *)(sp+8*si_+4), *(uint8_t *)(sp+8*si_+5), *(uint8_t *)(sp+8*si_+6), *(uint8_t *)(sp+8*si_+7),
               *(uint64_t *)(sp+8*si_)
              );
    }
    printf("+---------------------------------+-------------------------+--------------------+\n");
}

void bin_padding()
{
    asm volatile (".rept 2783; nop; .endr");
}

void win_authed(int token)
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    if (token != 0x1337) return;

    puts("You win! Here is your flag:");
    flag_fd = open("/flag", 0);
    if (flag_fd < 0)
    {
        printf("\n  ERROR: Failed to open the flag -- %s!\n", strerror(errno));
        if (geteuid() != 0)
        {
            printf("  Your effective user id is not 0!\n");
            printf("  You must directly run the suid binary in order to have the correct permissions!\n");
        }
        exit(-1);
    }
    flag_length = read(flag_fd, flag, sizeof(flag));
    if (flag_length <= 0)
    {
        printf("\n  ERROR: Failed to read the flag -- %s!\n", strerror(errno));
        exit(-1);
    }
    write(1, flag, flag_length);
    printf("\n\n");
}

int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[48];
    } data  = {0} ;

    unsigned long size = 0;

    puts("The challenge() function has just been launched!");

    GET_FRAME_WORDS(sz_, sp_, bp_, rp_);
    puts("Before we do anything, let's take a look at challenge()'s stack frame:");
    DUMP_STACK(sp_, sz_);
    printf("Our stack pointer points to %p, and our base pointer points to %p.\n", sp_, bp_);
    printf("This means that we have (decimal) %d 8-byte words in our stack frame,\n", sz_);
    printf("including the saved base pointer and the saved return address, for a\n");
    printf("total of %d bytes.\n", sz_ * 8);
    printf("The input buffer begins at %p, partway through the stack frame,\n", &data.input);
    printf("(\"above\" it in the stack are other local variables used by the function).\n");
    printf("Your input will be read into this buffer.\n");
    printf("The buffer is %d bytes long, but the program will let you provide an arbitrarily\n", 48);
    printf("large input length, and thus overflow the buffer.\n\n");

    printf("In this level, there is no \"win\" variable.\n");
    printf("You will need to force the program to execute the win_authed() function\n");
    printf("by directly overflowing into the stored return address back to main,\n");
    printf("which is stored at %p, %d bytes after the start of your input buffer.\n", rp_, rp_ - (unsigned long) &data.input);
    printf("That means that you will need to input at least %d bytes (%d to fill the buffer,\n", rp_ + 8 - (unsigned long) &data.input, 48);
    printf("%d to fill other stuff stored between the buffer and the return address,\n", rp_ - (unsigned long) &data.input - 48);
    printf("and 8 that will overwrite the return address).\n\n");

    puts("We have disabled the following standard memory corruption mitigations for this challenge:");
    puts("- the canary is disabled, otherwise you would corrupt it before");
    puts("overwriting the return address, and the program would abort.");

    size = 4096;

    printf("You have chosen to send %lu bytes of input!\n", size);
    printf("This will allow you to write from %p (the start of the input buffer)\n", &data.input);
    printf("right up to (but not including) %p (which is %d bytes beyond the end of the buffer).\n", size + (unsigned long) &data.input, size - 48);

    printf("Of these, you will overwrite %d bytes into the return address.\n", (long)((unsigned long) &data.input + size - rp_));
    printf("If that number is greater than 8, you will overwrite the entire return address.\n\n");

    puts("One caveat in this challenge is that the win_authed() function must first auth:");
    puts("it only lets you win if you provide it with the argument 0x1337.");
    puts("Speifically, the win_authed() function looks something like:");
    puts("    void win_authed(int token)");
    puts("    {");
    puts("      if (token != 0x1337) return;");
    puts("      puts(\"You win! Here is your flag: \");");
    puts("      sendfile(1, open(\"/flag\", 0), 0, 256);");
    puts("      puts(\"\");");
    puts("    }");
    puts("");

    printf("So how do you pass the check? There *is* a way, and we will cover it later,\n");
    printf("but for now, we will simply bypass it! You can overwrite the return address\n");
    printf("with *any* value (as long as it points to executable code), not just the start\n");
    printf("of functions. Let's overwrite past the token check in win!\n\n");

    printf("To do this, we will need to analyze the program with objdump, identify where\n");
    printf("the check is in the win_authed() function, find the address right after the check,\n");
    printf("and write that address over the saved return address.\n\n");

    printf("Go ahead and find this address now. When you're ready, input a buffer overflow\n");
    printf("that will overwrite the saved return address (at %p, %d bytes into the buffer)\n", rp_, rp_ - (unsigned long)&data.input);
    printf("with the correct value.\n\n");

    puts("This challenge is careful about reading your input: it will allocate a correctly-sized temporary");
    puts("buffer on the heap, and then copy the data over to the stack. Can you figure out a way to fool");
    puts("this technique and cause an overflow?");
    char *tmp_input = malloc(size);
    assert(tmp_input != 0);
    printf("Send your payload (up to %lu bytes)!\n", size);
    int received = read(0, tmp_input, (unsigned long) size);
    puts("Checking length of received string...");
    size_t string_length = strlen(tmp_input);
    assert(string_length < 48);
    printf("Passed! We should have enough space for all %d bytes of it on the stack. Copying all %d received bytes!\n", string_length, received);
    memcpy(&data.input, tmp_input, received);

    if (received < 0)
    {
        printf("ERROR: Failed to read input -- %s!\n", strerror(errno));
        exit(1);
    }

    printf("You sent %d bytes!\n", received);

    printf("Let's see what happened with the stack:\n\n");
    DUMP_STACK(sp_, sz_);

    printf("The program's memory status:\n");
    printf("- the input buffer starts at %p\n", &data.input);
    printf("- the saved frame pointer (of main) is at %p\n", bp_);
    printf("- the saved return address (previously to main) is at %p\n", rp_);
    printf("- the saved return address is now pointing to %p.\n", *(unsigned long*)(rp_));
    printf("- the address of win_authed() is %p.\n", win_authed);
    printf("\n");

    printf("If you have managed to overwrite the return address with the correct value,\n");
    printf("challenge() will jump straight to win_authed() when it returns.\n");
    printf("Let's try it now!\n\n", 0);

    if (received + ((unsigned long) &data.input) > rp_ + 2)
    {
        puts("WARNING: You sent in too much data, and overwrote more than two bytes of the address.");
        puts("         This can still work, because I told you the correct address to use for");
        puts("         this execution, but you should not rely on that information.");
        puts("         You can solve this challenge by only overwriting two bytes!");
        puts("         ");
    }

    puts("Goodbye!");

    return 0;
}

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    char crash_resistance[0x1000];

    challenge(argc, argv, envp);

}